name: 'Pollinate AI - Automated Feature Implementation'
description: 'AI-powered feature implementation with automated testing, code review, and multi-language support'
author: 'CJ Hauser'

branding:
  icon: 'zap'
  color: 'green'

inputs:
  pollinations_api_key:
    description: 'Pollinations AI API key'
    required: false
    default: 'TOEAP3DuMvvVHUsy'
  github_token:
    description: 'GitHub token for creating PRs and comments'
    required: true
    default: ${{ github.token }}
  base_branch:
    description: 'Base branch to create PRs against'
    required: false
    default: 'main'
  auto_assign_reviewers:
    description: 'Automatically assign reviewers based on file history'
    required: false
    default: 'true'
  enable_security_scan:
    description: 'Run security scans on generated code'
    required: false
    default: 'true'
  enable_tests:
    description: 'Run automated tests before creating PR'
    required: false
    default: 'true'
  enable_linting:
    description: 'Run linting checks on generated code'
    required: false
    default: 'true'

runs:
  using: 'composite'
  steps:
    - name: Check out repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'

    - name: Parse command and feature request
      id: parse
      shell: bash
      run: |
        COMMENT="${{ github.event.comment.body }}"
        
        # Extract command type
        if echo "$COMMENT" | grep -qi "^!Pollinate explain"; then
          echo "command=explain" >> $GITHUB_OUTPUT
          FEATURE_DESC=$(echo "$COMMENT" | sed 's/^!Pollinate explain//I' | xargs)
        elif echo "$COMMENT" | grep -qi "^!Pollinate refine"; then
          echo "command=refine" >> $GITHUB_OUTPUT
          FEATURE_DESC=$(echo "$COMMENT" | sed 's/^!Pollinate refine//I' | xargs)
        elif echo "$COMMENT" | grep -qi "^!Pollinate rollback"; then
          echo "command=rollback" >> $GITHUB_OUTPUT
          FEATURE_DESC=""
        else
          echo "command=implement" >> $GITHUB_OUTPUT
          FEATURE_DESC=$(echo "$COMMENT" | sed 's/^!Pollinate//I' | xargs)
        fi
        
        echo "feature_description=$FEATURE_DESC" >> $GITHUB_OUTPUT
        BRANCH_NAME="pollinate/$(echo "$FEATURE_DESC" | head -c 30 | tr '[:upper:]' '[:lower:]' | tr ' ' '-' | sed 's/[^a-z0-9-]//g')-$(date +%s)"
        echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT

    - name: Handle rollback command
      if: steps.parse.outputs.command == 'rollback'
      uses: actions/github-script@v7
      with:
        github-token: ${{ inputs.github_token }}
        script: |
          const { data: prs } = await github.rest.pulls.list({
            owner: context.repo.owner,
            repo: context.repo.repo,
            state: 'open',
            sort: 'created',
            direction: 'desc'
          });
          
          const pollinatePR = prs.find(pr => pr.title.includes('ðŸŒ± Pollinate:') || pr.labels.some(l => l.name === 'pollinate'));
          
          if (pollinatePR) {
            await github.rest.pulls.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pollinatePR.number,
              state: 'closed'
            });
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `ðŸ”„ **Rollback complete!**\n\nClosed PR #${pollinatePR.number} and rolled back changes.`
            });
          } else {
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `âš ï¸ No recent Pollinate PR found to rollback.`
            });
          }

    - name: Detect project language and structure
      if: steps.parse.outputs.command != 'rollback'
      id: detect
      shell: bash
      run: |
        if [ -f "package.json" ]; then
          echo "language=javascript" >> $GITHUB_OUTPUT
          echo "package_manager=npm" >> $GITHUB_OUTPUT
          [ -f "yarn.lock" ] && echo "package_manager=yarn" >> $GITHUB_OUTPUT
          [ -f "pnpm-lock.yaml" ] && echo "package_manager=pnpm" >> $GITHUB_OUTPUT
        elif [ -f "requirements.txt" ] || [ -f "pyproject.toml" ]; then
          echo "language=python" >> $GITHUB_OUTPUT
        elif [ -f "go.mod" ]; then
          echo "language=go" >> $GITHUB_OUTPUT
        elif [ -f "Cargo.toml" ]; then
          echo "language=rust" >> $GITHUB_OUTPUT
        elif [ -f "pom.xml" ] || [ -f "build.gradle" ]; then
          echo "language=java" >> $GITHUB_OUTPUT
        else
          echo "language=unknown" >> $GITHUB_OUTPUT
        fi
        
        if grep -q "jest" package.json 2>/dev/null; then
          echo "test_framework=jest" >> $GITHUB_OUTPUT
        elif grep -q "vitest" package.json 2>/dev/null; then
          echo "test_framework=vitest" >> $GITHUB_OUTPUT
        elif grep -q "pytest" requirements.txt 2>/dev/null; then
          echo "test_framework=pytest" >> $GITHUB_OUTPUT
        fi

    - name: Gather smart context
      if: steps.parse.outputs.command != 'rollback'
      id: context
      shell: bash
      run: |
        echo "=== Gathering Repository Context ===" > context.txt
        echo "" >> context.txt
        
        echo "## Project Structure:" >> context.txt
        find . -type f -not -path '*/\.*' -not -path '*/node_modules/*' -not -path '*/dist/*' -not -path '*/build/*' | head -100 >> context.txt
        echo "" >> context.txt
        
        if [ -f "package.json" ]; then
          echo "## Dependencies (package.json):" >> context.txt
          cat package.json >> context.txt
          echo "" >> context.txt
        fi
        
        if [ -f "requirements.txt" ]; then
          echo "## Dependencies (requirements.txt):" >> context.txt
          cat requirements.txt >> context.txt
          echo "" >> context.txt
        fi
        
        if [ -f "README.md" ]; then
          echo "## Current README.md:" >> context.txt
          head -50 README.md >> context.txt
          echo "" >> context.txt
        fi
        
        echo "## Common Code Patterns:" >> context.txt
        find . -name "*.js" -o -name "*.ts" -o -name "*.py" | head -10 | while read file; do
          echo "File: $file" >> context.txt
          head -20 "$file" >> context.txt
          echo "" >> context.txt
        done
        
        echo "## Issue Context:" >> context.txt
        echo "Issue #${{ github.event.issue.number }}" >> context.txt
        echo "Title: ${{ github.event.issue.title }}" >> context.txt
        echo "" >> context.txt

    - name: Explain implementation plan
      if: steps.parse.outputs.command == 'explain'
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github_token }}
      run: |
        PROMPT="Analyze this feature request and explain how you would implement it.

        $(cat context.txt)

        Feature request: ${{ steps.parse.outputs.feature_description }}

        Provide a detailed implementation plan including:
        1. Files that need to be created or modified
        2. Key changes to make in each file
        3. Testing strategy
        4. Potential edge cases or considerations
        
        Format as a clear, bulleted explanation."
        
        RESPONSE=$(curl -s https://text.pollinations.ai/openai/ \
          -H "content-type: application/json" \
          -H "authorization: Bearer ${{ inputs.pollinations_api_key }}" \
          -d "{
            \"messages\": [
              {
                \"role\": \"user\",
                \"content\": $(echo "$PROMPT" | jq -Rs .)
              }
            ],
            \"model\": \"openai\"
          }")
        
        EXPLANATION=$(echo "$RESPONSE" | jq -r '.choices[0].message.content // .content // .')
        
        gh issue comment ${{ github.event.issue.number }} --body "## ðŸŒ± Pollinate Implementation Plan

        $EXPLANATION

        ---
        React with ðŸ‘ and comment \`!Pollinate ${{ steps.parse.outputs.feature_description }}\` to proceed with implementation."

    - name: Create feature branch
      if: steps.parse.outputs.command == 'implement' || steps.parse.outputs.command == 'refine'
      shell: bash
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        
        if [ "${{ steps.parse.outputs.command }}" == "refine" ]; then
          LATEST_BRANCH=$(git branch -r | grep "pollinate/" | tail -1 | sed 's/.*\///')
          if [ -n "$LATEST_BRANCH" ]; then
            git checkout "$LATEST_BRANCH"
          else
            git checkout -b ${{ steps.parse.outputs.branch_name }}
          fi
        else
          git checkout -b ${{ steps.parse.outputs.branch_name }}
        fi

    - name: Call AI to implement feature
      if: steps.parse.outputs.command == 'implement' || steps.parse.outputs.command == 'refine'
      id: ai_implement
      shell: bash
      run: |
        CONTEXT=$(cat context.txt)
        
        LANG_GUIDANCE=""
        case "${{ steps.detect.outputs.language }}" in
          javascript)
            LANG_GUIDANCE="Use modern JavaScript/TypeScript. Follow ES6+ standards. Use async/await for async operations."
            ;;
          python)
            LANG_GUIDANCE="Follow PEP 8 style guide. Use type hints. Include docstrings for functions."
            ;;
          go)
            LANG_GUIDANCE="Follow Go conventions. Use proper error handling. Include package documentation."
            ;;
          rust)
            LANG_GUIDANCE="Follow Rust conventions. Handle Result/Option types properly. Include documentation comments."
            ;;
        esac
        
        REFINE_CONTEXT=""
        if [ "${{ steps.parse.outputs.command }}" == "refine" ]; then
          REFINE_CONTEXT="This is a refinement request. Review the existing implementation and improve it based on: ${{ steps.parse.outputs.feature_description }}"
        fi
        
        PROMPT="You are implementing a feature for a GitHub repository.

        $CONTEXT

        Language: ${{ steps.detect.outputs.language }}
        $LANG_GUIDANCE

        Feature request: ${{ steps.parse.outputs.feature_description }}
        $REFINE_CONTEXT

        Implement this feature by creating or modifying files. Include:
        1. Implementation files with complete, production-ready code
        2. Test files for the new functionality
        3. Updated documentation (README, inline comments)
        4. Any configuration changes needed

        Return ONLY a valid JSON array (no markdown, no explanation):
        [
          {
            \"action\": \"create\",
            \"path\": \"path/to/file.js\",
            \"content\": \"// Complete file content here\",
            \"description\": \"Brief description of this change\"
          }
        ]

        Rules:
        - Use 'create' for new files, 'modify' for existing files, 'delete' to remove files
        - Include complete file content for create/modify actions
        - Add comprehensive inline comments
        - Generate test files with multiple test cases
        - Update README.md if new features are user-facing
        - Return valid JSON only, no other text"
        
        RESPONSE=$(curl -s https://text.pollinations.ai/openai/ \
          -H "content-type: application/json" \
          -H "authorization: Bearer ${{ inputs.pollinations_api_key }}" \
          -d "{
            \"messages\": [
              {
                \"role\": \"user\",
                \"content\": $(echo "$PROMPT" | jq -Rs .)
              }
            ],
            \"model\": \"openai\"
          }")
        
        CONTENT=$(echo "$RESPONSE" | jq -r '.choices[0].message.content // .content // .')
        
        echo "$CONTENT" | sed -n '/^\[/,/^\]/p' > changes.json
        
        if [ ! -s changes.json ]; then
          echo "$CONTENT" | sed -n '/```json/,/```/p' | sed '1d;$d' > changes.json
        fi
        
        if [ ! -s changes.json ]; then
          echo "$CONTENT" | grep -o '\[.*\]' > changes.json
        fi

    - name: Apply changes
      if: steps.parse.outputs.command == 'implement' || steps.parse.outputs.command == 'refine'
      shell: bash
      run: |
        node << 'EOF'
        const fs = require('fs');
        const path = require('path');
        
        let changesText = fs.readFileSync('changes.json', 'utf8').trim();
        
        let changes;
        try {
          changes = JSON.parse(changesText);
        } catch (e) {
          const match = changesText.match(/\[[\s\S]*\]/);
          if (match) {
            changes = JSON.parse(match[0]);
          } else {
            console.error('No valid JSON array found in response');
            process.exit(1);
          }
        }
        
        if (!Array.isArray(changes)) {
          console.error('Changes is not an array');
          process.exit(1);
        }
        
        const changeSummary = [];
        
        for (const change of changes) {
          if (!change.path || !change.action) continue;
          
          const filePath = change.path;
          const dir = path.dirname(filePath);
          
          if (change.action === 'create' || change.action === 'modify') {
            if (!fs.existsSync(dir)) {
              fs.mkdirSync(dir, { recursive: true });
            }
            fs.writeFileSync(filePath, change.content || '');
            changeSummary.push(`- ${change.action}: \`${filePath}\` - ${change.description || 'No description'}`);
          } else if (change.action === 'delete') {
            if (fs.existsSync(filePath)) {
              fs.unlinkSync(filePath);
              changeSummary.push(`- deleted: \`${filePath}\``);
            }
          }
        }
        
        fs.writeFileSync('change_summary.txt', changeSummary.join('\n'));
        EOF

    - name: Run quality checks
      if: (steps.parse.outputs.command == 'implement' || steps.parse.outputs.command == 'refine') && (inputs.enable_linting == 'true' || inputs.enable_tests == 'true' || inputs.enable_security_scan == 'true')
      shell: bash
      continue-on-error: true
      run: |
        if [ "${{ inputs.enable_linting }}" == "true" ]; then
          echo "## Linting Results" > lint_results.txt
          if [ "${{ steps.detect.outputs.language }}" == "javascript" ]; then
            if command -v eslint &> /dev/null; then
              eslint . --ext .js,.ts,.jsx,.tsx >> lint_results.txt 2>&1 || true
            fi
          fi
        fi
        
        if [ "${{ inputs.enable_tests }}" == "true" ]; then
          echo "## Test Results" > test_results.txt
          if [ "${{ steps.detect.outputs.test_framework }}" == "jest" ]; then
            npm test >> test_results.txt 2>&1 || true
          elif [ "${{ steps.detect.outputs.test_framework }}" == "vitest" ]; then
            npm run test >> test_results.txt 2>&1 || true
          fi
        fi
        
        if [ "${{ inputs.enable_security_scan }}" == "true" ]; then
          echo "## Security Scan Results" > security_results.txt
          if [ "${{ steps.detect.outputs.language }}" == "javascript" ]; then
            npm audit >> security_results.txt 2>&1 || true
          fi
        fi

    - name: Commit and push
      if: steps.parse.outputs.command == 'implement' || steps.parse.outputs.command == 'refine'
      shell: bash
      run: |
        FEATURE="${{ steps.parse.outputs.feature_description }}"
        
        if echo "$FEATURE" | grep -qi "fix\|bug"; then
          TYPE="fix"
        elif echo "$FEATURE" | grep -qi "doc"; then
          TYPE="docs"
        elif echo "$FEATURE" | grep -qi "test"; then
          TYPE="test"
        elif echo "$FEATURE" | grep -qi "refactor"; then
          TYPE="refactor"
        else
          TYPE="feat"
        fi
        
        MSG="$TYPE: $(echo $FEATURE | head -c 50)"
        
        git add .
        git commit -m "$MSG" -m "Generated by Pollinate AI" || echo "No changes to commit"
        git push origin ${{ steps.parse.outputs.branch_name }} --force

    - name: Create Pull Request
      if: steps.parse.outputs.command == 'implement' || steps.parse.outputs.command == 'refine'
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github_token }}
      run: |
        CHANGE_SUMMARY=$(cat change_summary.txt 2>/dev/null || echo "No summary available")
        LINT_RESULTS=$(cat lint_results.txt 2>/dev/null || echo "Linting disabled")
        TEST_RESULTS=$(cat test_results.txt 2>/dev/null || echo "Testing disabled")
        SECURITY_RESULTS=$(cat security_results.txt 2>/dev/null || echo "Security scan disabled")
        
        gh pr create \
          --title "ðŸŒ± Pollinate: ${{ steps.parse.outputs.feature_description }}" \
          --body "## ðŸŒ± AI-Generated Implementation

        **Feature:** ${{ steps.parse.outputs.feature_description }}
        **Language:** ${{ steps.detect.outputs.language }}

        ### Changes
        $CHANGE_SUMMARY

        <details><summary>Quality Checks</summary>

        **Linting:**
        \`\`\`
        $LINT_RESULTS
        \`\`\`

        **Tests:**
        \`\`\`
        $TEST_RESULTS
        \`\`\`

        **Security:**
        \`\`\`
        $SECURITY_RESULTS
        \`\`\`
        </details>" \
          --label "ai-generated,pollinate" \
          --base ${{ inputs.base_branch }} \
          --head ${{ steps.parse.outputs.branch_name }} || true
